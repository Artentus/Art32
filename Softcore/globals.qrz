fn flog2(n_bits) {
    n_bits >>= 1;
    let log = 0;
    while n_bits != 0 {
        n_bits >>= 1;
        log += 1;
    }
    log
}

fn clog2(n_bits) {
    n_bits -= 1;
    let log = 0;
    while n_bits != 0 {
        n_bits >>= 1;
        log += 1;
    }
    log
}

fn max(a, b) {
    if a > b { a } else { b }
}

extern mod Pll (
    in sig clk25: bit,

    out sig clk200: bit,
    out sig clk80: bit,
    out sig clk40: bit,
    out sig locked: bit,
);

extern mod Mult16 (
    in sig SignA: bit,
    in sig SignB: bit,
    in sig A: bits<16>,
    in sig B: bits<16>,
    out sig P: bits<32>,
);

extern mod KernelRam (
    in sig instr_addr_in: bits<13>,
    out reg instr_out: bits<32>,

    in sig data_addr_in: bits<13>,
    in sig data_in: bits<32>,
    out reg data_out: bits<32>,
    in sig data_byte_enable: bits<4>,
    in sig data_write: bit,

    in sig clk: bit,
);

extern mod DDR (
    in sig d_in: bits<2>,
    out sig d_out: bit,

    in sig reset: bit,
    in sig clk: bit,
);

struct Flags {
    carry   : bit,
    zero    : bit,
    sign    : bit,
    overflow: bit,
}

enum AdderOp: bits<2> {
    Add  = 0x0,
    AddC = 0x1,
    Sub  = 0x2,
    SubC = 0x3,
}

enum MultOp: bits<2> {
    MulUU = 0b00,
    MulSS = 0b11,
    MulUS = 0b01,
}

enum AluOp: bits<5> {
    Add = 0x00,
    Sub = 0x01,
    And = 0x02,
    Or  = 0x03,
    Xor = 0x04,
    Shl = 0x05,
    Lsr = 0x06,
    Asr = 0x07,

    AddC = 0x08,
    SubC = 0x09,

    Cond = 0x0F,

    Mul    = 0x10,
    MulHuu = 0x11,
    MulHss = 0x12,
    MulHus = 0x13,
    Divu   = 0x14,
    Divs   = 0x15,
    Remu   = 0x16,
    Rems   = 0x17,

    Nop = 0x1F,
}

enum Condition: bits<3> {
    Equal                  = 0x0, // Z
    NotEqual               = 0x1, // !Z
    UnsignedLessThan       = 0x2, // !C
    UnsignedGreaterOrEqual = 0x3, // C
    SignedLessThan         = 0x4, // S != O
    SignedGreaterOrEqual   = 0x5, // S == O
    Always                 = 0x6, // true
    Never                  = 0x7, // false
}

enum OpCode16: bits<3> {
    Misc        = 0x0,
    Jump        = 0x1,
    LoadImm     = 0x2,
    AddImm      = 0x3,
    LoadStoreSp = 0x4,
    SpecialSp   = 0x5,
    Branch      = 0x6,
    Inst32      = 0x7,
}

enum OpCode32: bits<5> {
    AluRegReg  = 0x00,
    AluRegImm  = 0x01,
    MoveRegReg = 0x02,
    MoveRegImm = 0x03,
    CarryExt   = 0x04,
    Jump       = 0x05,
    Load       = 0x06,
    Store      = 0x07,
    MulExt     = 0x08,
    Nop        = 0x1F,
}

enum MiscCode: bits<3> {
    Nop       = 0x0,
    Return    = 0x1,
    IntReturn = 0x2,
    Syscall   = 0x3,
    Move      = 0x4,
    Compare   = 0x5,
    Alu       = 0x6,
    ShiftImm  = 0x7,
}

enum LhsBusSource: bits<3> {
    Register = 0b000,
    Pc       = 0b001,
    Syscall  = 0b010,
    Forward3 = 0b100,
    Forward4 = 0b101,
    Forward5 = 0b110,
}

enum RhsBusSource: bits<3> {
    Register  = 0b000,
    Pc        = 0b001,
    Immediate = 0b010,
    Forward3  = 0b100,
    Forward4  = 0b101,
    Forward5  = 0b110,
}

enum DataBusSource: bit {
    Result = 0b0,
    Memory = 0b1,
}

enum MemoryMode: bits<2> {
    Bits32 = 0b00,
    Bits8  = 0b01,
    Bits16 = 0b10,
    IO     = 0b11,
}
