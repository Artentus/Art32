fn flog2(n_bits) {
    n_bits >>= 1;
    let log = 0;
    while n_bits != 0 {
        n_bits >>= 1;
        log += 1;
    }
    log
}

fn clog2(n_bits) {
    n_bits -= 1;
    let log = 0;
    while n_bits != 0 {
        n_bits >>= 1;
        log += 1;
    }
    log
}

fn max(a, b) {
    if a > b { a } else { b }
}

extern mod Pll (
    in sig clk25: bit,

    out sig clk200: bit,
    out sig clk80: bit,
    out sig clk40: bit,
    out sig locked: bool,
);

extern mod KernelRam (
    in sig instr_addr_in: bits<13>,
    out reg instr_out: bits<32>,

    in sig data_addr_in: bits<13>,
    in sig data_in: bits<32>,
    out reg data_out: bits<32>,
    in sig data_byte_enable: bits<4>,
    in sig data_write: bool,

    in sig clk: bit,
);

extern mod DDR (
    in sig d_in: bits<2>,
    out sig d_out: bit,

    in sig reset: bool,
    in sig clk: bit,
);

const REG_ZERO = 0;
const REG_RA = 1;
const REG_SP = 2;

struct Flags {
    carry: bit,
    zero: bool,
    sign: bool,
    overflow: bool,
}

enum LhsBusSource: bits<3> {
    Register       = 0b000,
    ProgramCounter = 0b001,
    Interrupt      = 0b010,
    Ira            = 0b011,
    Forward3       = 0b101,
    Forward4       = 0b110,
    Forward5       = 0b111,
}

enum RhsBusSource: bits<3> {
    Register       = 0b000,
    ProgramCounter = 0b001,
    Immediate      = 0b010,
    Forward3       = 0b101,
    Forward4       = 0b110,
    Forward5       = 0b111,
}

enum DataBusSource: bits<2> {
    Execute = 0b00,
    Memory  = 0b01,
    Stc     = 0b10,
}

enum MemoryMode: bits<2> {
    Bits32 = 0b00,
    Bits8  = 0b01,
    Bits16 = 0b10,
    IO     = 0b11,
}

enum PrivilegeLevel: bit {
    System = 0b0,
    User   = 0b1,
}

enum InterruptState: bit {
    Servicing = 0b0,
    Listening = 0b1,
}

enum InterruptKind: bits<2> {
    Hardware,
    Software,
    Exception,
}

struct DecodedInstruction {
    alu_op: AluOp,
    move_condition: Condition,
    jump_condition: Condition,
    load_flags: bool,
    reg_lhs_select: bits<5>,
    reg_rhs_select: bits<5>,
    reg_load_select: bits<5>,
    interrupt_kind: InterruptKind,
    interrupt_slot: bits<4>,
    load_ira: bool,
    lhs_bus_source: LhsBusSource,
    rhs_bus_source: RhsBusSource,
    data_bus_source: DataBusSource,
    set_interrupt_state: bool,
    new_interrupt_state: InterruptState,
    mem_enable: bool,
    mem_mode: MemoryMode,
    mem_sign_ext: bool,
    mem_write: bool,
    mem_reserve: bool,
}
